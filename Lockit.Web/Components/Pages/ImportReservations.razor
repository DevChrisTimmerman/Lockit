@page "/import-reservations"
@using EasyCsv.Components
@using EasyCsv.Core
@using MudBlazor.Utilities
@using Lockit.Models.Services

<MudStepper ShowResetButton OnPreviewInteraction="OnPreviewInteraction">
	<ChildContent>
		<MudStep Title="Load reservations" HasError="!_headerMatcher?.ValidateRequiredHeaders() ?? true">
			<div class="mb-4 d-flex gap-5" style="flex-direction: row; align-items: baseline;">
				<MudText Class="mb-4" Typo="Typo.h4">Locker reservations</MudText>
				@if (_reservationsCsv != null)
				{
					<MudButton Style="height: fit-content;" Variant="Variant.Filled" Color="Color.Error" OnClick="() => { _reservationsCsv = null; _records = null; }">Reset</MudButton>
				}
			</div>
			@if (_reservationsCsv == null)
			{
				<CsvFileInput CsvValid="_reservationsCsv != null" OnCsvUpload="x => _reservationsCsv = x.Csv" ButtonTooltip="Upload locker reservations" ButtonText="Upload locker reservations" />
			}
			else
			{
				<CsvTableHeaderMatcher HideDefaultValueColumn="true" @ref="_headerMatcher" Csv="_reservationsCsv" AllHeadersValidChanged="StateHasChanged" ExpectedHeaders="_expectedHeaders" AutoMatch="AutoMatching.Lenient"/>
			}
		</MudStep>
		<MudStep Title="Reservations overview">
			<MudTable Class="mt-7" Items="_records" Height="calc(80vh - (var(--mud-appbar-height) + 60px))" Filter="new Func<Student, bool>(SearchFunc)" Outlined Virtualize Dense Hover FixedHeader>
				<ToolBarContent>
					<MudText Typo="Typo.h6">All Reservations</MudText>
					<MudSpacer />
					<MudTextField @bind-Value="_searchString" Placeholder="Search" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"/>
				</ToolBarContent>
				<HeaderContent>
					<MudTh >Name</MudTh>
					<MudTh >Last Name</MudTh>
					<MudTh >Class</MudTh>
					<MudTh >Email</MudTh>
				</HeaderContent>
				<RowTemplate>
					<MudTd>@context.Name</MudTd>
					<MudTd>@context.LastName</MudTd>
					<MudTd>@context.Class</MudTd>
					<MudTd>@context.Email</MudTd>
				</RowTemplate>
				<PagerContent>
					<MudTablePager PageSizeOptions="new[] { 25, 100, int.MaxValue }"
								   RowsPerPageString="Rows per page"
								   AllItemsText="All"
								   InfoFormat="{first_item}-{last_item} // {all_items}"/>
				</PagerContent>
			</MudTable>
		</MudStep>
		<MudStep Title="Set preferences">
			<MudDropContainer T="PrefDropItem" @bind-Items="_prefrences" ItemsSelector="@((item,dropzone) => true)" ItemDropped="ItemUpdated">
				<ChildContent>
					<MudPaper Class="ma-4 flex-grow-1">
						<MudList T="string" Class="d-flex flex-column mud-height-full">
							<MudListSubheader>Locker Assignment Preferences</MudListSubheader>
							<MudDropZone T="PrefDropItem" Identifier="1" Class="flex-grow-1" AllowReorder Tag="@_prefrences.Count" />
						</MudList>
					</MudPaper>
				</ChildContent>
				<ItemRenderer>
					<div class="mb-4 mr-4 d-flex gap-6" style="flex-direction: row; align-items: baseline;">
						<MudIconButton Icon="@Icons.Material.Filled.DragHandle" Color="Color.Primary" Class="ml-2 align-self-center mud-cursor-move pointer-events-none" />
						<MudSelect @bind-Value="@context.Year" Label="Year preference" Variant="Variant.Outlined" Style="min-width: 180px">
							<MudSelectItem Value="1">1st years</MudSelectItem>
							<MudSelectItem Value="2"> 2nd years</MudSelectItem>
							<MudSelectItem Value="3"> 3rd years</MudSelectItem>
							<MudSelectItem Value="4"> 4th years</MudSelectItem>
							<MudSelectItem Value="5"> 5th years</MudSelectItem>
							<MudSelectItem Value="6"> 6th years</MudSelectItem>
						</MudSelect>
						<MudSelect @bind-Value="@context.LocationID" Label="Location preference" Variant="Variant.Outlined" AdornmentIcon="@Icons.Material.Filled.LocationSearching" FullWidth Validation="() => context.LocationID != -1">
								<MudSelectItem  Value="-1">Choose a location</MudSelectItem>
							@foreach (var loc in _locations)
							{
								<MudSelectItem  Value="@loc.ID">@loc.Name</MudSelectItem>
							}
						</MudSelect>
					</div>

				</ItemRenderer>
			</MudDropContainer>
			<MudStack Row AlignItems="AlignItems.Center" Justify="Justify.FlexEnd">
				<MudItem>
					<MudSwitch @bind-Value="@_sequentialIsEqual" Color="Color.Primary" Label="Treat sequential same year prefs as equal" />
				</MudItem>
				<MudItem>
				<MudDivider Vertical DividerType="DividerType.Middle"/>
				</MudItem>
				<MudItem>
					<MudIconButton Icon="@Icons.Material.Filled.AddCircle" OnClick="AddPref" Color="Color.Success"/>
					<MudIconButton Disabled="_locations.Count <= 0" Icon="@Icons.Material.Filled.Cancel" OnClick="RemovePref" Color="Color.Secondary"/>
				</MudItem>
			</MudStack>
		</MudStep>
		<MudStep Title="Review assignments">
			@if (_proposedAssignments?.Any() != true)
			{
				<div class="d-flex justify-center ma-15">
					<MudButton StartIcon="@Icons.Material.Filled.GeneratingTokens" Variant="Variant.Filled" Color="Color.Success" OnClick="AutoAssignLockers">Generate Locker Assignments</MudButton>
				</div>
			}
			else
			{
				<div class="mb-4 d-flex gap-4" style="flex-direction: row; align-items: baseline;">
					<MudText Typo="Typo.h6">Proposed Assignments (@_proposedAssignments.Count)</MudText>
					<MudButton StartIcon="@Icons.Material.Filled.Refresh" Variant="Variant.Outlined" Color="Color.Secondary" OnClick="AutoAssignLockers">Regenerate</MudButton>
					<MudSpacer />
					<MudButton StartIcon="@Icons.Material.Filled.Save" Variant="Variant.Filled" Color="Color.Primary" OnClick="CommitAssignments" Disabled="_isCommitting">
						@if (_isCommitting)
						{
							<MudProgressCircular Class="mr-3" Size="Size.Small" Indeterminate="true" />
							<span>Saving...</span>
						}
						else
						{
							<span>Save All Assignments</span>
						}
					</MudButton>
				</div>

				<MudTable Items="_proposedAssignments" Filter="new Func<KeyValuePair<Student, Locker>, bool>(SearchFunc)" Height="calc(70vh - (var(--mud-appbar-height) + 60px))" Outlined Virtualize Dense Hover FixedHeader>
					<ToolBarContent>
						<MudText Typo="Typo.h6">Assignment Preview</MudText>
						<MudSpacer />
						<MudTextField @bind-Value="_assignmentSearchString" Placeholder="Search assignments" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"/>
					</ToolBarContent>
					<HeaderContent>
						<MudTh><MudTableSortLabel SortBy="new Func<KeyValuePair<Student, Locker>, object>(x => x.Key.Name)">Name</MudTableSortLabel></MudTh>
						<MudTh><MudTableSortLabel SortBy="new Func<KeyValuePair<Student, Locker>, object>(x => x.Key.Class)">Class</MudTableSortLabel></MudTh>
						<MudTh><MudTableSortLabel SortBy="new Func<KeyValuePair<Student, Locker>, object>(x => CsvProcessService.ParseStudentYear(x.Key.Class))">Year</MudTableSortLabel></MudTh>
						<MudTh><MudTableSortLabel SortBy="new Func<KeyValuePair<Student, Locker>, object>(x => x.Value.Number)">Locker #</MudTableSortLabel></MudTh>
						<MudTh><MudTableSortLabel SortBy="new Func<KeyValuePair<Student, Locker>, object>(x => _locationNameLookup.GetValueOrDefault(x.Value.LocationID, string.Empty))">Location</MudTableSortLabel></MudTh>
						<MudTh><MudTableSortLabel SortBy="new Func<KeyValuePair<Student, Locker>, object>(x => CsvProcessService.ParseStudentYear(x.Key.Class))">Priority</MudTableSortLabel></MudTh>
					</HeaderContent>
					<RowTemplate>
						<MudTd>@($"{context.Key.Name} {context.Key.LastName}")</MudTd>
						<MudTd>@context.Key.Class</MudTd>
						<MudTd>@(CsvProcessService.ParseStudentYear(context.Key.Class))</MudTd>
						<MudTd>@context.Value.Number</MudTd>
						<MudTd>@(_locationNameLookup.GetValueOrDefault(context.Value.LocationID, "Unknown"))</MudTd>
						<MudTd>
							<MudChip T="string" Size="Size.Small" Color="@LockerAssignmentService.GetYearPriorityColor(CsvProcessService.ParseStudentYear(context.Key.Class))">
								@LockerAssignmentService.GetYearPriorityText(CsvProcessService.ParseStudentYear(context.Key.Class))
							</MudChip>
						</MudTd>
					</RowTemplate>
					<PagerContent>
						<MudTablePager PageSizeOptions="new[] { 25, 100, int.MaxValue }"
									   RowsPerPageString="Rows per page"
									   AllItemsText="All"
									   InfoFormat="{first_item}-{last_item} // {all_items}"/>
					</PagerContent>
				</MudTable>

				<MudDivider Class="my-6" />

				<MudText Typo="Typo.h6" Class="mb-4">Locker Assignments by Location</MudText>
				
				@if (_swapMode)
				{
					<MudAlert Class="mb-4" Severity="Severity.Info" ShowCloseIcon="true" CloseIconClicked="CancelSwapMode">
						<MudText><strong>Swap Mode Active</strong></MudText>
						<MudText>Selected: <strong>@_firstSelectedLockerNumber</strong>. Click on another assigned locker to swap students.</MudText>
					</MudAlert>
				}
				else
				{
					<MudAlert Class="mb-4" Severity="Severity.Normal">
						<MudText><strong>Click on any assigned locker to start swapping students between lockers.</strong></MudText>
					</MudAlert>
				}

				<MudGrid Class="pa-4" Justify="Justify.SpaceEvenly">
					@foreach (var location in _locations)
					{
						var locationAssignments = _proposedAssignments.Where(a => a.Value.LocationID == location.ID).ToList();
						if (locationAssignments.Any())
						{
							<MudPaper Elevation="3" Class="pa-4 ma-2">
								<MudGrid>
									<MudItem Style="width: auto; min-width: 100px">
										<MudText Typo="Typo.h6">@location.Name</MudText>
										<MudText Typo="Typo.body2">Assigned: @locationAssignments.Count</MudText>
										@if (!string.IsNullOrEmpty(location.Prefix))
										{
											<MudText Typo="Typo.body2">Prefix: @location.Prefix</MudText>
										}
									</MudItem>
									<MudItem>
										<MudDivider Vertical/>
									</MudItem>
									<MudItem>
										<MudText Typo="Typo.body2">Total Capacity: @location.LockerCount</MudText>
										<MudText Typo="Typo.body2">Per Column: @location.LockersPerColumn</MudText>
										<MudText Typo="Typo.body2">Remaining: @(location.LockerCount - locationAssignments.Count)</MudText>
									</MudItem>
								</MudGrid>
								<MudItem Class="mt-4">
									<MudStack Row Justify="Justify.Center">
										@{
											var columns = location.LockersPerColumn;
											var rows = location.LockerCount / columns;
											@for (var rowIndex = 0; rowIndex < rows; rowIndex++)
											{
												var currentRowIndex = rowIndex;
												<MudStack>
													@for (var colIndex = 0; colIndex < columns; colIndex++)
													{
														var lockerIndex = currentRowIndex * columns + colIndex;
														var lockerNumber = LockerAssignmentService.GetLockerNumber(location, lockerIndex + 1);
														var assignment = locationAssignments.FirstOrDefault(a => a.Value.Number == lockerNumber);
														var isAssigned = assignment.Key != null;
														var studentYear = isAssigned ? CsvProcessService.ParseStudentYear(assignment.Key.Class) : 0;
														var priorityColor = isAssigned ? LockerAssignmentService.GetYearPriorityColor(studentYear) : Color.Surface;
														var borderStyle = GetLockerBorderStyle(lockerNumber, isAssigned, priorityColor);
														var bgColor = isAssigned ? LockerAssignmentService.GetPriorityBackgroundColor(studentYear) : "var(--mud-palette-surface)";
														var textColor = isAssigned ? "var(--mud-palette-text-primary)" : "var(--mud-palette-text-secondary)";
														var cursorStyle = GetLockerCursorStyle(isAssigned);
														
														<MudTooltip>
															<ChildContent>
																<MudPaper @onclick="() => OnLockerClick(lockerNumber)" Outlined Class="pa-1 ma-0" Style="@($"background-color: {bgColor}; {borderStyle} color: {textColor}; min-width: 45px; text-align: center; {cursorStyle}")">
																	<MudText Typo="Typo.caption">@lockerNumber</MudText>
																	@if (isAssigned)
																	{
																		<MudText Typo="Typo.caption" Color="Color.Warning" Style="font-size: 0.6rem;">@studentYear</MudText>
																	}
																</MudPaper>
															</ChildContent>
															<TooltipContent>
																@if (isAssigned)
																{
																	<MudText Typ="Typo.body2"><strong>@lockerNumber</strong></MudText>
																	<MudText Typ="Typo.body2">@assignment.Key.Name @assignment.Key.LastName</MudText>
																	<MudText Typ="Typo.body2">Class: @assignment.Key.Class</MudText>
																	<MudText Typ="Typo.body2">Year: @studentYear (@LockerAssignmentService.GetYearPriorityText(studentYear))</MudText>
																	@if (isAssigned)
																	{
																		<MudDivider Class="my-2" />
																		<MudText Typ="Typo.caption" Color="Color.Info">Click to swap students</MudText>
																	}
																}
																else
																{
																	<MudText Typ="Typo.body2">@lockerNumber - Available</MudText>
																}
															</TooltipContent>
														</MudTooltip>
													}
												</MudStack>
											}
										}
									</MudStack>
								</MudItem>
							</MudPaper>
						}
					}
				</MudGrid>

				@if (_unassignedStudents?.Any() == true)
				{
					<MudAlert Class="mt-4" Severity="Severity.Warning">
						<MudText><strong>@_unassignedStudents.Count students could not be assigned:</strong></MudText>
						@foreach (var student in _unassignedStudents.Take(10))
						{
							<MudText Typo="Typo.body2">• @student.Name @student.LastName (@student.Class)</MudText>
						}
						@if (_unassignedStudents.Count > 10)
						{
							<MudText Typo="Typo.body2">... and @(_unassignedStudents.Count - 10) more</MudText>
						}
					</MudAlert>
				}
			}
		</MudStep>
	</ChildContent>
</MudStepper>

@code {
	[Inject] 
	public IDialogService DialogService { get; set; }
	[Inject]
	public LocationService LocationService { get; set; }
	[Inject]
	public LockerAssignmentService LockerAssignmentService { get; set; }
	[Inject]
	public CsvProcessService CsvProcessService { get; set; }

	private CsvTableHeaderMatcher _headerMatcher;
	private IEasyCsv? _reservationsCsv;

	private List<Student>? _records;
	private List<Location> _locations;
	private bool _sequentialIsEqual;

	// Performance optimization: Create lookup dictionaries
	private Dictionary<int, string> _locationNameLookup = new();

	// Assignment tracking
	private Dictionary<Student, Locker>? _proposedAssignments;
	private List<Student>? _unassignedStudents;
	private bool _isCommitting = false;
	private string _vacantLockerSort = "zzz";

	// Locker swap functionality
	private string? _firstSelectedLockerNumber;
	private string? _secondSelectedLockerNumber;
	private bool _swapMode = false;

	protected override async Task OnInitializedAsync()
	{
		_locations = await LocationService.GetAllLocationsAsync();
		// Create lookup dictionaries for O(1) performance
		_locationNameLookup = _locations.ToDictionary(l => l.ID, l => l.Name);
	}

	private readonly List<ExpectedHeader> _expectedHeaders = new ()
	{
		new ExpectedHeader(nameof(Student.Name), ExpectedHeaderConfig.Required),
		new ExpectedHeader(nameof(Student.LastName), ExpectedHeaderConfig.Required),
		new ExpectedHeader(nameof(Student.Email), ExpectedHeaderConfig.Default),
		new ExpectedHeader(nameof(Student.Class), ExpectedHeaderConfig.Required),
		new ExpectedHeader(nameof(Student.SCUID)),
	};

	private string _searchString = string.Empty;
	private string _assignmentSearchString = string.Empty;

	private async Task GetRows()
	{
		if (_headerMatcher == null) return;
		var allRecords = await _headerMatcher.GetRecords<Student>();

		var result = await CsvProcessService.ProcessStudentRecords(allRecords);
		_records = result.UniqueStudents;
	}

	private void ItemUpdated(MudItemDropInfo<PrefDropItem> dropItem)
	{
		_prefrences.UpdateOrder(dropItem, item => item.Index, dropItem.IndexInZone);
	}

	private async Task OnPreviewInteraction(StepperInteractionEventArgs arg)
	{
		switch (arg.Action)
		{
			case StepAction.Complete:
				// occurs when clicking next
				await ControlStepCompletion(arg);
				break;
			case StepAction.Activate:
				// occurs when clicking a step header with the mouse
				//await ControlStepNavigation(arg);
				break;
			case StepAction.Reset:
				// occurs when clicking the reset button
				// Reset all assignment data
				_proposedAssignments = null;
				_unassignedStudents = null;
				// Reset swap mode state
				_firstSelectedLockerNumber = null;
				_secondSelectedLockerNumber = null;
				_swapMode = false;
				break;
			case StepAction.Skip:
				// occurs when clicking the skip button
				break;
		}
	}

	private async Task ControlStepCompletion(StepperInteractionEventArgs arg)
	{
		switch (arg.StepIndex) {
			case 0: // CVS upload step
				if (!_headerMatcher?.ValidateRequiredHeaders() ?? true)
				{
					await DialogService.ShowMessageBox("Error", "Please ensure all required headers are present");
					arg.Cancel = true;
				}
				else
				{
					await GetRows();
				}
				break;
			case 1: // CVS overview step

				break;
			case 2: // Preferences step
				// Validate preferences
				if (_prefrences.Any(p => p.LocationID == -1))
				{
					await DialogService.ShowMessageBox("Error", "Please ensure all preferences have a location assigned");
					arg.Cancel = true;
				}
				break;
			case 3: // Review assignments step
				if (_proposedAssignments?.Any() != true)
				{
					await DialogService.ShowMessageBox("Error", "Please generate locker assignments first");
					arg.Cancel = true;
				}
				break;
		}
	}

	private List<PrefDropItem> _prefrences = new()
	{
		new PrefDropItem(){ Year = 1 ,Index = 0},
		new PrefDropItem(){ Year = 2 ,Index = 1},
		new PrefDropItem(){ Year = 3 ,Index = 2},
	};

	private void AddPref()
	{
		_prefrences.Add(new PrefDropItem());
	}

	private void RemovePref()
	{
		_prefrences.RemoveAt(_prefrences.Count - 1);
	}

	private async Task AutoAssignLockers()
	{
		if (_records == null || !_records.Any())
		{
			await DialogService.ShowMessageBox("Error", "No students to assign lockers to.");
			return;
		}

		try
		{
			// Reset swap mode when regenerating assignments
			_firstSelectedLockerNumber = null;
			_secondSelectedLockerNumber = null;
			_swapMode = false;

			var result = await LockerAssignmentService.AutoAssignLockersAsync(_records, _locations, _prefrences, _sequentialIsEqual);
			if (result.IsSuccess)
			{
				_proposedAssignments = result.ProposedAssignments;
				_unassignedStudents = result.UnassignedStudents;
				StateHasChanged();
			}
			else
			{
				await DialogService.ShowMessageBox("Error", $"An error occurred during assignment: {result.ErrorMessage}");
			}
		}
		catch (Exception ex)
		{
			await DialogService.ShowMessageBox("Error", $"An error occurred during assignment: {ex.Message}");
		}
	}

	private async Task CommitAssignments()
	{
		if (_proposedAssignments?.Any() != true)
		{
			await DialogService.ShowMessageBox("Error", "No assignments to commit.");
			return;
		}

		_isCommitting = true;
		StateHasChanged();

		try
		{
			var result = await LockerAssignmentService.CommitAssignmentsAsync(_proposedAssignments);

			//TODO: cleanup this summary
			// Show completion summary
			var locationBreakdown = string.Join("\n", 
				_locations.Select(loc => {
					var count = _proposedAssignments.Count(a => a.Value.LocationID == loc.ID);
					return count > 0 ? $"- {loc.Name}: {count} students" : null;
				}).Where(x => x != null));

			var summaryMessage = $"Assignment completed!\n\n" +
								$"Successfully assigned: {result.SuccessCount}\n" +
								$"Errors: {result.ErrorCount}\n" +
								$"Students unassigned: {_unassignedStudents?.Count ?? 0}\n\n";

			if (!string.IsNullOrEmpty(locationBreakdown))
			{
				summaryMessage += $"Breakdown by location:\n{locationBreakdown}";
			}

			if (result.Errors.Any())
			{
				summaryMessage += $"\n\nErrors:\n{string.Join("\n", result.Errors.Take(5))}";
				if (result.Errors.Count > 5)
				{
					summaryMessage += $"\n... and {result.Errors.Count - 5} more errors";
				}
			}

			await DialogService.ShowMessageBox("Assignment Complete", summaryMessage);

			// Clear assignments after successful commit
			if (result.IsSuccess)
			{
				_proposedAssignments = null;
				_unassignedStudents = null;
				// Reset swap mode state
				_firstSelectedLockerNumber = null;
				_secondSelectedLockerNumber = null;
				_swapMode = false;
			}
		}
		catch (Exception ex)
		{
			await DialogService.ShowMessageBox("Error", $"An error occurred during commit: {ex.Message}");
		}
		finally
		{
			_isCommitting = false;
			StateHasChanged();
		}
	}

	private async Task OnLockerClick(string lockerNumber)
	{
		if (_proposedAssignments == null) return;

		// Find the assignment for this locker
		var assignment = _proposedAssignments.FirstOrDefault(a => a.Value.Number == lockerNumber);
		var isAssigned = assignment.Key != null;

		// Only allow clicking on assigned lockers
		if (!isAssigned) return;

		if (!_swapMode)
		{
			// Start swap mode
			_firstSelectedLockerNumber = lockerNumber;
			_swapMode = true;
		}
		else if (_firstSelectedLockerNumber == lockerNumber)
		{
			// Clicked the same locker - cancel swap mode
			_firstSelectedLockerNumber = null;
			_swapMode = false;
		}
		else
		{
			// Second locker selected - perform swap
			_secondSelectedLockerNumber = lockerNumber;
			await PerformLockerSwap();
		}

		StateHasChanged();
	}

	private async Task PerformLockerSwap()
	{
		if (_proposedAssignments == null || string.IsNullOrEmpty(_firstSelectedLockerNumber) || string.IsNullOrEmpty(_secondSelectedLockerNumber))
			return;

		try
		{
			// Find both assignments
			var firstAssignment = _proposedAssignments.FirstOrDefault(a => a.Value.Number == _firstSelectedLockerNumber);
			var secondAssignment = _proposedAssignments.FirstOrDefault(a => a.Value.Number == _secondSelectedLockerNumber);

			if (firstAssignment.Key == null || secondAssignment.Key == null)
			{
				await DialogService.ShowMessageBox("Error", "One or both selected lockers are not assigned.");
				return;
			}

			// Get the students
			var firstStudent = firstAssignment.Key;
			var secondStudent = secondAssignment.Key;

			// Get the lockers
			var firstLocker = firstAssignment.Value;
			var secondLocker = secondAssignment.Value;

			// Remove the old assignments
			_proposedAssignments.Remove(firstStudent);
			_proposedAssignments.Remove(secondStudent);

			// Add the swapped assignments
			_proposedAssignments.Add(firstStudent, secondLocker);
			_proposedAssignments.Add(secondStudent, firstLocker);
		}
		catch (Exception ex)
		{
			await DialogService.ShowMessageBox("Error", $"An error occurred during swap: {ex.Message}");
		}
		finally
		{
			// Reset swap mode
			_firstSelectedLockerNumber = null;
			_secondSelectedLockerNumber = null;
			_swapMode = false;
		}
	}

	private void CancelSwapMode()
	{
		_firstSelectedLockerNumber = null;
		_secondSelectedLockerNumber = null;
		_swapMode = false;
		StateHasChanged();
	}

	private string GetLockerBorderStyle(string lockerNumber, bool isAssigned, Color priorityColor)
	{
		var baseBorder = isAssigned ? "border: 2px solid var(--mud-palette-" + priorityColor.ToString().ToLower() + ");" : "border: 1px solid var(--mud-palette-lines-default);";
		
		// Add selection highlighting
		if (_swapMode && _firstSelectedLockerNumber == lockerNumber)
		{
			return "border: 3px solid var(--mud-palette-primary); box-shadow: 0 0 8px var(--mud-palette-primary);";
		}
		
		return baseBorder;
	}

	private string GetLockerCursorStyle(bool isAssigned)
	{
		return isAssigned ? "cursor: pointer;" : "cursor: default;";
	}

	private bool SearchFunc(KeyValuePair<Student, Locker> assignment)
	{
		if (string.IsNullOrWhiteSpace(_assignmentSearchString))
			return true;

		var student = assignment.Key;
		var locker = assignment.Value;
		// Use lookup dictionary instead of FirstOrDefault
		var locationName = _locationNameLookup.GetValueOrDefault(locker.LocationID, string.Empty);

		return student.Name.Contains(_assignmentSearchString, StringComparison.OrdinalIgnoreCase) ||
			   student.LastName.Contains(_assignmentSearchString, StringComparison.OrdinalIgnoreCase) ||
			   student.Class.Contains(_assignmentSearchString, StringComparison.OrdinalIgnoreCase) ||
			   student.Email.Contains(_assignmentSearchString, StringComparison.OrdinalIgnoreCase) ||
			   locker.Number.Contains(_assignmentSearchString, StringComparison.OrdinalIgnoreCase) ||
			   locationName.Contains(_assignmentSearchString, StringComparison.OrdinalIgnoreCase);
	}

	private bool SearchFunc(Student student)
	{
		if (string.IsNullOrWhiteSpace(_searchString))
			return true;
		return student.Name.Contains(_searchString, StringComparison.OrdinalIgnoreCase) ||
			   student.LastName.Contains(_searchString, StringComparison.OrdinalIgnoreCase) ||
			   student.Class.Contains(_searchString, StringComparison.OrdinalIgnoreCase) ||
			   student.Email.Contains(_searchString, StringComparison.OrdinalIgnoreCase);
	}
}
