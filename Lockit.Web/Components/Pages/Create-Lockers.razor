@page "/create-lockers"


@* @if (AppStateService.IsLocationSetupComplete)
{
	<MudAlert Severity="Severity.Info">
		<MudStack Row AlignItems="AlignItems.Center" Spacing="1">
		You are all set to go! <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Success"/>
		</MudStack>
	</MudAlert>
	return;
} *@

<MudStepper ShowResetButton OnPreviewInteraction="OnPreviewInteraction">
	<ChildContent>
		<MudStep Title="Setup locker locations" HasError="@_locationsStepHasErrors">
			<MudChip T="string" Color=Color.Primary>Setup locker locations</MudChip>
			@foreach (var loc in _locations)
			{
				<MudPaper Elevation="3">
					<MudGrid Justify="Justify.FlexStart" Spacing="4" Class="ma-4">
						<MudItem xs="1">
							<MudTooltip ShowOnFocus Arrow Placement="Placement.Top" Text="Leave empty if no Prefix is wanted" Color="Color.Primary">
								<MudTextField Variant="Variant.Outlined" T="string" Label="Prefix" @bind-Value="@loc.Prefix"/>
							</MudTooltip>
						</MudItem>
						<MudItem xs="3">
							<MudTextField Variant="Variant.Outlined" T="string" Required Label="Name" @bind-Value="@loc.Name" />
						</MudItem>
						<MudItem xs="7">
							<MudTextField Variant="Variant.Outlined" T="string" Label="Description" @bind-Value="@loc.Description" AutoGrow MaxLines="3" HelperText="Leave empty if no Description is needed" HelperTextOnFocus />
						</MudItem>
					</MudGrid>
				</MudPaper>
			}
			<MudGrid Justify="Justify.FlexEnd">
				<MudItem>
					<MudIconButton Icon="@Icons.Material.Filled.AddCircle" OnClick="AddLocation" Color="Color.Success"/>
					<MudIconButton Disabled="_locations.Count < 2" Icon="@Icons.Material.Filled.Cancel" OnClick="RemoveLocation" Color="Color.Secondary"/>
				</MudItem>
			</MudGrid>
		</MudStep>
		<MudStep Title="Setup locker amounts" HasError="@_locationsAmountsHasError">
			<MudChip T="string" Color=Color.Primary>Setup locker amounts</MudChip>
			@for (int i = 0; i < _locations.Count; i++)
			{
				var loc = _locations[i];
				int index = i;
				<MudPaper Elevation="3">
					<MudStack Class="ma-4 pa-4" Row AlignItems="AlignItems.Center">
						<MudGrid Justify="Justify.FlexStart" Spacing="4" >
							<MudItem xs="1">
								<MudTextField Label="Prefix" ReadOnly @bind-Value="@loc.Prefix" Variant="Variant.Filled"/>
							</MudItem>
							<MudItem xs="4">
								<MudTextField Label="Name" ReadOnly @bind-Value="@loc.Name" Variant="Variant.Filled"/>
							</MudItem>
							<MudSpacer/>
							<MudItem xs="1">
								<MudIcon Icon="@Icons.Material.TwoTone.ArrowRightAlt"/>
							</MudItem>
							<MudSpacer/>
							<MudItem xs="2">
								<MudTextField Variant="Variant.Outlined" Required T="int" Label="Total lockers" @bind-Value="@loc.LockerCount"/>
							</MudItem>
							<MudItem xs="2">
								<MudTextField Variant="Variant.Outlined" Required T="int" Label="Lockers per column" @bind-Value="@loc.LockersPerColumn"/>
							</MudItem>
						</MudGrid>
					</MudStack>
				</MudPaper>
			}
		</MudStep>
		<MudStep Title="Overview">
			@if (_completed == false)
			{
				<MudChip T="string" Color=Color.Primary>Overview</MudChip>
				<MudGrid Class="pa-10" Justify="Justify.SpaceEvenly">
					@for (var i = 0; i < _locations.Count; i++)
					{
						var loc = _locations[i];
						int index = i;
						<MudPaper Elevation="3" Class="pa-4 ma-2">
							<MudItem>
								<MudGrid>
									<MudItem Style="width: auto; min-width: 100px">
										<MudText>@loc.Name </MudText>
										<MudText>Prefix: @loc.Prefix </MudText>
									</MudItem>
									<MudItem>
										<MudDivider Vertical/>
									</MudItem>
									<MudItem>
										<MudText>Total: @loc.LockerCount </MudText>
										<MudText>Per Column: @loc.LockersPerColumn </MudText>
									</MudItem>
									<MudItem>
										<MudStack Row Justify="Justify.Center">
											@foreach (var locker in _previewLocationLockers[index])
											{
												<MudPaper>
													@locker.Number
												</MudPaper>
											}
										</MudStack>
									</MudItem>
								</MudGrid>
							</MudItem>
						</MudPaper>
					}
				</MudGrid>
			}
		</MudStep>

		@if (_completed)
		{
			<MudGrid Justify="Justify.Center">
				<MudItem>
					@if (_isDBrequestProcessed)
					{
						<MudStack Row AlignItems="AlignItems.Center" Spacing="1">
						<MudText Class="ma-20">New lockers added! <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Color="Color.Success" /></MudText>
						</MudStack>
					}
					else
					{
						<div class="loader">
							<div class="box box0"><div></div></div>
							<div class="box box1"><div></div></div>
							<div class="box box2"><div></div></div>
							<div class="box box3"><div></div></div>
							<div class="box box4"><div></div></div>
							<div class="box box5"><div></div></div>
							<div class="box box6"><div></div></div>
							<div class="box box7"><div></div></div>
							<div class="ground"><div></div></div>
						</div>
					}
				</MudItem>
			</MudGrid>
		}
	</ChildContent>
</MudStepper>

@code {
	[Inject] 
	public IDialogService DialogService { get; set; }
	[Inject]
	public LocationService LocationService { get; set; }
	[Inject]
	public LockerService LockerService { get; set; }
	[Inject]
	public AppStateService AppStateService { get; set; }
	private List<Location> _locations = new List<Location>();

	private List<List<Locker>> _previewLocationLockers = new List<List<Locker>>();

	private bool _locationsStepHasErrors = false;
	private bool _locationsAmountsHasError = false;

	private bool _isDBrequestProcessed;
	private bool _completed;

	protected override async Task OnInitializedAsync()
	{
		// Initialize with one default location
		AddLocation();
	}

	private void AddLocation()
	{
		_locations.Add(new Location());
	}

	private void RemoveLocation()
	{
		_locations.RemoveAt(_locations.Count - 1);
	}

	private async Task OnPreviewInteraction(StepperInteractionEventArgs arg)
	{
		switch (arg.Action)
		{
			case StepAction.Complete:
				// occurs when clicking next
				await ControlStepCompletion(arg);
				break;
			case StepAction.Activate:
				// occurs when clicking a step header with the mouse
				//await ControlStepNavigation(arg);
				break;
			case StepAction.Reset:
				// occurs when clicking the reset button
				ResetPreviewLocationLocker();
				break;
			case StepAction.Skip:
				// occurs when clicking the skip button
				break;
		}
	}

	private void ResetPreviewLocationLocker()
	{
		_previewLocationLockers.Clear();
	}

	private async Task ControlStepCompletion(StepperInteractionEventArgs arg)
	{
		switch (arg.StepIndex) {
			case 0:
				if (ValidateLocations() == false)
				{
					await DialogService.ShowMessageBox("Error", "Name field is required");
					arg.Cancel = true;
				}
				break;
			case 1:
				if (ValidateLockerAmounts())
				{
					SetupLockerLocationPreviewList();
				}
				else
				{
					await DialogService.ShowMessageBox("Error", "Please enter valid locker counts for all locations, \r\n The total locker counter per location should be divisible by column count");
					arg.Cancel = true;
				}

				break;
			case 2:
				_completed = true;
				StateHasChanged();
				await FinalizeSetup();
				break;
		}
	}

	private bool ValidateLocations()
	{
		foreach (var loc in _locations)
		{
			if (string.IsNullOrWhiteSpace(loc.Name))
			{
				_locationsStepHasErrors = true;
				return false;
			}
		}

		_locationsStepHasErrors = false;
		return true;
	}

	private bool ValidateLockerAmounts()
	{
		foreach (var loc in _locations)
		{
			if (loc.LockerCount == 0 || loc.LockersPerColumn == 0)
			{
				_locationsAmountsHasError = true;
				return false;
			}

			//make sure they are divisable
			if (loc.LockerCount % loc.LockersPerColumn != 0)
			{
				_locationsAmountsHasError = true;
				return false;
			}
		}

		_locationsAmountsHasError = false;
		return true;
	}

	private void SetupLockerLocationPreviewList()
	{
		//Set the lockers per column for each location
		for (var i = 0; i < _locations.Count; i++)
		{
			_previewLocationLockers.Add(new List<Locker>());
			for (int j = 0; j < _locations[i].LockerCount; j++)
			{
				Locker locker = new Locker
				{
					Number = _locations[i].Prefix + (j + 1).ToString("D3"),
					LocationID = _locations[i].ID,
					StudentID = null,
					Student = null,
					Status = Enums.LockerStatus.Available
				};
				_previewLocationLockers[i].Add(locker);
			}
		}
	}

	private async Task<bool> FinalizeSetup()
	{
		foreach (var loc in _locations)
		{
			await LocationService.AddLocationAsync(loc);
		}

		foreach (List<Locker> locationLockers in _previewLocationLockers)
		{
			foreach (Locker locker in locationLockers)
			{
				await LockerService.AddLockerAsync(locker);
			}
		}

		//wait 3 seconds so the animation can be seen :)
		await Task.Delay(3000);
		_isDBrequestProcessed = true;
		return true;
	}

}
